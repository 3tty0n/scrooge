package com.twitter.scrooge
package scalagen

import java.io.File
import AST._

trait ScalaTemplate {
  val paths = List(
    "com.twitter.scrooge",
    "com.twitter.scrooge.scalagen",
    "com.twitter.scrooge.scalagen.ScalaGenerator",
    "com.twitter.scrooge.scalagen.StructTemplate",
    "com.twitter.scrooge.scalagen.ServiceTemplate"
  )
  def template[A: Manifest](text: String) = Template[A](text, paths)
}

object ScalaGenerator extends ScalaTemplate {
  val header = template[Document](
"""/**
 * Autogenerated by Scrooge
 * Edit this shit, I dare you.
 */

package {{scalaNamespace}}

import java.net.InetSocketAddress
import java.nio.ByteBuffer
import java.util.Arrays
import scala.collection.{Map, Set}
import scala.collection.mutable
import com.twitter.conversions.time._
import com.twitter.scrooge.ThriftStruct
import com.twitter.util.Future
import org.apache.thrift.TApplicationException
import org.apache.thrift.TEnum
import org.apache.thrift.protocol._
import org.apache.thrift.transport.{TMemoryInputTransport, TMemoryBuffer}
{{
  headers collect {
    case AST.Include(_, doc) => doc.scalaNamespace
  } filter(_ != scalaNamespace) map { ns =>
    "import " + ns + "._"
  } mkString("\n")
}}
""")

  val enumTemplate = Template[Enum](
"""
object {{name}} {
{{values.map { v => "case object " + v.name + " extends " + name + "(" + v.value + ")"}.indent}}

  def apply(value: Int): {{name}} = {
    value match {
{{values.map { v => "case " + v.value + " => " + v.name }.indent(3)}}
      case _ => throw new NoSuchElementException(value.toString)
    }
  }

  def get(value: Int): Option[{{name}}] = {
    value match {
{{values.map { v => "case " + v.value + " => Some(" + v.name + ")"}.indent(3)}}
      case _ => None
    }
  }
}

abstract class {{name}}(val value: Int) extends TEnum {
  def getValue = value
}
""")

  val constsTemplate = template[ConstList](
"""
// ----- constants

object Constants {
{{constList.map { e => constTemplate(e, scope) }.indent}}
}
""")

  val constTemplate = template[Const](
"""val {{name}}: {{scalaType(`type`)}} = {{constantTemplate(`type`, value)}}""")

  case class ConstList(constList: Seq[Const])
}


abstract sealed class ScalaServiceOption
case object WithFinagleClient extends ScalaServiceOption
case object WithFinagleService extends ScalaServiceOption
case object WithOstrichServer extends ScalaServiceOption

case class ScalaService(service: Service, options: Set[ScalaServiceOption])


// maybe should eventually go elsewhere.
class ScalaGenerator extends Generator {
  import ScalaGenerator._
  import StructTemplate._
  import ServiceTemplate._

  // Constants
  val stringTemplate = Template[StringConstant](""""{{value}}"""")
  val boolTemplate = Template[BoolConstant]("{{value.toString}}")
  val doubleTemplate = Template[DoubleConstant]("{{value.toString}}")
  val intTemplate = Template[IntConstant]("{{value.toString}}")
  val listTemplate = Template[ListConstant](
    """List({{elems.map { e => constantTemplate(null, e) }.mkString(", ")}})"""
  )
  val mapTemplate =  Template[MapConstant](
    """Map({{elems.asInstanceOf[Map[com.twitter.scrooge.AST.Constant, com.twitter.scrooge.AST.Constant]].map { case (x, y) => constantTemplate(null, x) + " -> " + constantTemplate(null, y) }.mkString(",\n")}})"""
    // """ fix texmate colorization
  )

  def constantTemplate(`type`: FieldType, constant: Constant): String = {
    constant match {
      case c @ StringConstant(_) =>
        stringTemplate(c, this)
      case c @ DoubleConstant(_) =>
        doubleTemplate(c, this)
      case c @ IntConstant(_) =>
        intTemplate(c, this)
      case c @ BoolConstant(_) =>
        boolTemplate(c, this)
      case c @ ListConstant(_) =>
        listTemplate(c, this)
      case c @ MapConstant(_) =>
        mapTemplate(c, this)
      case c @ Identifier(name) =>
        val prefix = `type`.asInstanceOf[NamedType].name + "."
        if (name startsWith prefix) name else prefix + name
      case NullConstant =>
        "null"
    }
  }

  def writeFieldConst(name: String) = name.toUpperCase + "_FIELD_DESC"

  def defaultValueTemplate(field: Field) = {
    field.default.map { d => constantTemplate(field.`type`, d) }.getOrElse {
      if (field.requiredness.isOptional) {
        "None"
      } else {
        field.`type` match {
          case TBool => "false"
          case TByte | TI16 | TI32 | TI64 => "0"
          case TDouble => "0.0"
          case _ => "null"
        }
      }
    }
  }

  def constType(t: FunctionType): String = {
    t match {
      case Void => "VOID"
      case TBool => "BOOL"
      case TByte => "BYTE"
      case TDouble => "DOUBLE"
      case TI16 => "I16"
      case TI32 => "I32"
      case TI64 => "I64"
      case TString => "STRING"
      case TBinary => "STRING" // thrift's idea of "string" is based on old broken c++ semantics.
      case StructType(_) => "STRUCT"
      case EnumType(_) => "I32" // enums are converted to ints
      case MapType(_, _, _) => "MAP"
      case SetType(_, _) => "SET"
      case ListType(_, _) => "LIST"
      case x => throw new InternalError("constType#" + t)
    }
  }

  def protocolReadMethod(t: FunctionType): String = {
    t match {
      case TBool => "readBool"
      case TByte => "readByte"
      case TI16 => "readI16"
      case TI32 => "readI32"
      case TI64 => "readI64"
      case TDouble => "readDouble"
      case TString => "readString"
      case TBinary => "readBinary"
      case x => throw new InternalError("protocolReadMethod#" + t)
    }
  }

  def protocolWriteMethod(t: FunctionType): String = {
    t match {
      case TBool => "writeBool"
      case TByte => "writeByte"
      case TI16 => "writeI16"
      case TI32 => "writeI32"
      case TI64 => "writeI64"
      case TDouble => "writeDouble"
      case TString => "writeString"
      case TBinary => "writeBinary"
      case x => throw new InternalError("protocolWriteMethod#" + t)
    }
  }

  def scalaType(t: FunctionType): String = {
    t match {
      case Void => "Unit"
      case TBool => "Boolean"
      case TByte => "Byte"
      case TI16 => "Short"
      case TI32 => "Int"
      case TI64 => "Long"
      case TDouble => "Double"
      case TString => "String"
      case TBinary => "ByteBuffer"
      case MapType(k, v, _) => "Map[" + scalaType(k) + ", " + scalaType(v) + "]"
      case SetType(x, _) => "Set[" + scalaType(x) + "]"
      case ListType(x, _) => "Seq[" + scalaType(x) + "]"
      case n: NamedType => n.name
    }
  }

  def scalaFieldType(f: Field): String = {
    if (f.requiredness.isOptional && f.default == None) {
      "Option[" + scalaType(f.`type`) + "]"
    } else {
      scalaType(f.`type`)
    }
  }

  def fieldArgs(args: Seq[Field]): String = {
    args.map { f =>
      val prefix = f.name + ": " + scalaFieldType(f)
      val suffix = f.default.map { d => constantTemplate(f.`type`, d) } orElse {
        f.requiredness match {
          case Requiredness.Optional => Some("None")
          case _ => None
        }
      } map { " = " + _ }
      prefix + suffix.getOrElse("")
    }.mkString(", ")
  }

  // deprecated (for tests)
  def apply(doc: Document, enum: Enum): String = header(doc, this) + enumTemplate(enum, this)
  def apply(doc: Document, consts: ConstList): String = header(doc, this) + constsTemplate(consts, this)
  def apply(doc: Document, struct: StructLike): String = header(doc, this) + structTemplate(struct, this)
  def apply(doc: Document, service: Service): String = header(doc, this) + serviceTemplate(ScalaService(service, Set()), this)

  def apply(_doc: Document, serviceOptions: Set[ScalaServiceOption]): String = {
    val doc = _doc.camelize

    val consts = doc.defs.collect {
      case c @ Const(_, _, _) => c
    }
    val constSection = if (consts.size > 0) {
      constsTemplate(ConstList(consts), this)
    } else {
      ""
    }

    val enums = doc.defs.collect {
      case enum @ Enum(_, _) => enum
    }
    val enumSections = enums.map { enum => enumTemplate(enum, this) }
    val enumSection = if (enumSections.size > 0) {
      "\n// ----- enums\n\n" + enumSections.mkString("\n")
    } else {
      ""
    }

    val structs = doc.defs.collect {
      case s: StructLike => s
    }
    val structSections = structs.map { x => structTemplate(x, this) }
    val structSection = structSections.mkString("", "\n\n", "\n\n")

    val services = doc.defs.collect {
      case s @ Service(_, _, _) => s
    }
    val serviceSections = services.map { x =>
      serviceTemplate(ScalaService(x, serviceOptions), this)
    }
    val serviceSection = serviceSections.mkString("", "\n\n", "\n\n")

    header(doc, this) + constSection + enumSection + structSection + serviceSection
  }
}
