package com.twitter.scrooge

import com.twitter.scrooge.AST._
import org.apache.thrift.protocol.TProtocol

trait ThriftStruct {
  def write(oprot: TProtocol)
}

object ScalaGenerator {

  val header =
"""/**
 * Autogenerated by Scrooge
 * Edit this shit, I dare you.
 */

package {{scalaNamespace}}

import scala.collection._
"""

  val enumTemplateText =
header + """import org.apache.thrift.TEnum

object {{name}} {
{{values.map { v => "case object " + v.name + " extends " + name + "(" + v.value + ")"}.indent}}

  def apply(value: Int): Option[{{name}}] = {
    value match {
{{values.map { v => "case " + v.value + " => Some(" + v.name + ")"}.indent(3)}}
      case _ => None
    }
  }
}

abstract class {{name}}(val value: Int) {
  def toThrift = new TEnum {
    override def getValue = {
      value
    }
  }
}"""

  val constsTemplateText =
header + """object Constants {
{{constList.map { e => constTemplate(e, scope) }.indent}}
}
"""

  val constTemplateText = "val {{name}}: {{scalaType(`type`)}} = {{constantTemplate(`type`, value)}}"


  // ----- readers

  val readBasicTemplateText = """_iprot.{{ protocolReadMethod(self) }}()"""

  val readBinaryTemplateText =
"""val _buffer = _iprot.readBinary()
val _bytes = new Array[Byte](_buffer.remaining)
_buffer.get(_bytes)
_bytes
"""

  val readListTemplateText =
"""val _list = _iprot.readListBegin()
val _rv = new mutable.ListBuffer[{{ scalaType(self.asInstanceOf[AST.ListType].tpe) }}]
var _i = 0
while (_i < _list.size) {
  _rv += {
{{ val t = self.asInstanceOf[AST.ListType].tpe; structReadTemplate(t)(t, scope).indent(2) }}
  }
  _i += 1
}
_iprot.readListEnd()
_rv.toList
"""

  val readSetTemplateText =
"""val _set = _iprot.readSetBegin()
val _rv = new mutable.HashSet[{{ scalaType(self.asInstanceOf[AST.SetType].tpe) }}]
var _i = 0
while (_i < _set.size) {
  _rv += {
{{ val t = self.asInstanceOf[AST.SetType].tpe; structReadTemplate(t)(t, scope).indent(2) }}
  }
  _i += 1
}
_iprot.readSetEnd()
_rv
"""

  val readMapTemplateText =
"""val _map = _iprot.readMapBegin()
val _rv = new mutable.HashMap[{{ val t = self.asInstanceOf[AST.MapType]; scalaType(t.keyType) + ", " + scalaType(t.valueType) }}]
var _i = 0
while (_i < _map.size) {
  val _key = {
{{ val t = self.asInstanceOf[AST.MapType].keyType; structReadTemplate(t)(t, scope).indent(2) }}
  }
  val _value = {
{{ val t = self.asInstanceOf[AST.MapType].valueType; structReadTemplate(t)(t, scope).indent(2) }}
  }
  _rv(_key) = _value
  _i += 1
}
_iprot.readMapEnd()
_rv
"""

  val readStructTemplateText = """{{self.asInstanceOf[AST.ReferenceType].name}}.decoder(_iprot)"""

  val readFieldTemplateText =
"""case {{id.toString}} => { /* {{name}} */
  _field.`type` match {
    case TType.{{constType(`type`)}} => {
      {{name}} = {
{{ structReadTemplate(`type`)(`type`, scope).indent(4) }}
      }
    }
    case _ => TProtocolUtil.skip(_iprot, _field.`type`)
  }
}
"""


  // ----- writers

  val writeBasicTemplateText = """oprot.{{protocolWriteMethod(self)}}(_item)"""

  val writeBinaryTemplateText = """oprot.writeBinary(ByteBuffer.wrap(_item))"""

  val writeListTemplateText =
"""oprot.writeListBegin(new TList(TType.{{constType(self.asInstanceOf[AST.ListType].tpe)}}, _item.size))
_item.foreach { _item =>
{{ val t = self.asInstanceOf[AST.ListType].tpe; writeTemplate(t)(t, scope).indent(1) }}
}
oprot.writeListEnd()
"""

  val writeSetTemplateText =
"""oprot.writeSetBegin(new TSet(TType.{{constType(self.asInstanceOf[AST.SetType].tpe)}}, _item.size))
_item.foreach { _item =>
{{ val t = self.asInstanceOf[AST.SetType].tpe; writeTemplate(t)(t, scope).indent(1) }}
}
oprot.writeSetEnd()
"""

  val writeMapTemplateText =
"""oprot.writeMapBegin(new TMap(TType.{{constType(self.asInstanceOf[AST.MapType].keyType)}}, TType.{{constType(self.asInstanceOf[AST.MapType].valueType)}}, _item.size))
_item.foreach { case (_key, _value) =>
  {
    val _item = _key
{{ val t = self.asInstanceOf[AST.MapType].keyType; writeTemplate(t)(t, scope).indent(2) }}
  }
  {
    val _item = _value
{{ val t = self.asInstanceOf[AST.MapType].valueType; writeTemplate(t)(t, scope).indent(2) }}
  }
}
oprot.writeMapEnd()
"""

  val writeStructTemplateText = """_item.write(oprot)"""

  val writeFieldTemplateText =
"""if ({{
`type` match {
  case AST.TBool | AST.TByte | AST.TI16 | AST.TI32 | AST.TI64 | AST.TDouble =>
    "true"
  case _ =>
    name + " ne null"
}
}}) {
  val _item = {{name}}
  oprot.writeFieldBegin({{ writeFieldConst(name) }})
{{ writeTemplate(`type`)(`type`, scope).indent(1) }}
  oprot.writeFieldEnd()
}
"""

  val structTemplateText =
header + """import java.nio.ByteBuffer
import org.apache.thrift.protocol._
import com.twitter.scrooge.ThriftStruct

object {{name}} {
  object decoder extends (TProtocol => ThriftStruct) {
    override def apply(_iprot: TProtocol) = {
      var _field: TField = null
{{ fields.map { f => "var " + f.name + ": " + scalaType(f.`type`) + " = " + defaultValueTemplate(f) }.indent(3) }}

      var _done = false
      _iprot.readStructBegin()
      while (!_done) {
        _field = _iprot.readFieldBegin
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
{{ fields.map { f => readFieldTemplate(f, scope) }.indent(6) }}
            case _ => TProtocolUtil.skip(_iprot, _field.`type`)
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
      new {{name}}({{ fields.map { f => f.name }.mkString(", ") }})
    }
  }
}

case class {{name}}({{fields.map { f => f.name + ": " + scalaType(f.`type`) }.mkString(", ")}}) extends ThriftStruct {
  private val STRUCT_DESC = new TStruct("{{name}}")
{{fields.map { f => "private val " + writeFieldConst(f.name) + " = new TField(\"" + f.name + "\", TType." + constType(f.`type`) + ", " + f.id.toString + ")"}.indent}}

  override def write(oprot: TProtocol) {
    validate()

    oprot.writeStructBegin(STRUCT_DESC)
{{fields.map { f => writeFieldTemplate(f, scope) }.indent(2) }}
    oprot.writeFieldStop()
    oprot.writeStructEnd()
  }

  def validate() = true //TODO: Implement this
}"""

  case class ScalaService(scalaNamespace: String, javaNamespace: String, service: Service)
  case class ConstList(constList: Array[Const])
}

// maybe should eventually go elsewhere.
class ScalaGenerator {
  import ScalaGenerator._

  var scalaNamespace: String = null
  var javaNamespace: String = null

  val enumTemplate = Template[Enum](enumTemplateText)
  val constsTemplate = Template[ConstList](constsTemplateText)
  val constTemplate = Template[Const](constTemplateText)
  val structTemplate = Template[Struct](structTemplateText)

  // readers
  val readBasicTemplate = Template[FieldType](readBasicTemplateText)
  val readBinaryTemplate = Template[FieldType](readBinaryTemplateText)
  val readListTemplate = Template[FieldType](readListTemplateText)
  val readSetTemplate = Template[FieldType](readSetTemplateText)
  val readMapTemplate = Template[FieldType](readMapTemplateText)
  val readStructTemplate = Template[FieldType](readStructTemplateText)
  val readFieldTemplate = Template[Field](readFieldTemplateText)

  // writers
  val writeBasicTemplate = Template[FieldType](writeBasicTemplateText)
  val writeBinaryTemplate = Template[FieldType](writeBinaryTemplateText)
  val writeListTemplate = Template[FieldType](writeListTemplateText)
  val writeSetTemplate = Template[FieldType](writeSetTemplateText)
  val writeMapTemplate = Template[FieldType](writeMapTemplateText)
  val writeStructTemplate = Template[FieldType](writeStructTemplateText)
  val writeFieldTemplate = Template[Field](writeFieldTemplateText)

  // Constants
  val stringTemplate = Template[StringConstant](""""{{value}}"""")
  val doubleTemplate = Template[DoubleConstant]("{{value.toString}}")
  val intTemplate = Template[IntConstant]("{{value.toString}}")
  val listTemplate = Template[ListConstant](
    """List({{elems.map { e => constantTemplate(null, e) }.mkString(", ")}})"""
  )
  val mapTemplate =  Template[MapConstant](
    """Map({{elems.asInstanceOf[Map[com.twitter.scrooge.AST.Constant, com.twitter.scrooge.AST.Constant]].map { case (x, y) => constantTemplate(null, x) + " -> " + constantTemplate(null, y) }.mkString(",\n")}})"""
  )

  def constantTemplate(`type`: FieldType, constant: Constant): String = {
    constant match {
      case c @ StringConstant(_) =>
        stringTemplate(c, this)
      case c @ DoubleConstant(_) =>
        doubleTemplate(c, this)
      case c @ IntConstant(_) =>
        intTemplate(c, this)
      case c @ ListConstant(_) =>
        listTemplate(c, this)
      case c @ MapConstant(_) =>
        mapTemplate(c, this)
      case c @ Identifier(name) =>
        `type`.asInstanceOf[ReferenceType].name + "." + name
    }
  }

  def writeFieldConst(name: String) = name.toUpperCase + "_FIELD_DESC"

  def writeTemplate(t: FieldType): Template[FieldType] = {
    t match {
      case TBinary => writeBinaryTemplate
      case _: ListType => writeListTemplate
      case _: SetType => writeSetTemplate
      case _: MapType => writeMapTemplate
      case _: ReferenceType => writeStructTemplate
      case _ => writeBasicTemplate
    }
  }

  def structReadTemplate(t: FieldType): Template[FieldType] = {
    t match {
      case TBinary => readBinaryTemplate
      case _: ListType => readListTemplate
      case _: SetType => readSetTemplate
      case _: MapType => readMapTemplate
      case _: ReferenceType => readStructTemplate
      case _ => readBasicTemplate
    }
  }

  def defaultValueTemplate(field: Field) = {
    field.default.map { d => constantTemplate(field.`type`, d) }.getOrElse {
      field.`type` match {
        case TBool => "false"
        case TByte | TI16 | TI32 | TI64 => "0"
        case TDouble => "0.0"
        case _ => "null"
      }
    }
  }

  def constType(t: FunctionType): String = {
    t match {
      case Void => "VOID"
      case TBool => "BOOL"
      case TByte => "BYTE"
      case TDouble => "DOUBLE"
      case TI16 => "I16"
      case TI32 => "I32"
      case TI64 => "I64"
      case TString => "STRING"
      case TBinary => "STRING" // IDK why, but Binary fields are marked as String
      case ReferenceType(_) => "STRUCT" // FIXME could also be Enum
      case MapType(_, _, _) => "MAP"
      case SetType(_, _) => "SET"
      case ListType(_, _) => "LIST"
      case x => "????" + x + "????"
    }
  }

  def protocolReadMethod(t: FunctionType): String = {
    t match {
      case TBool => "readBool"
      case TByte => "readByte"
      case TI16 => "readI16"
      case TI32 => "readI32"
      case TI64 => "readI64"
      case TDouble => "readDouble"
      case TString => "readString"
      case TBinary => "readBinary"
      case x => "????" + x + "????"
    }
  }

  def protocolWriteMethod(t: FunctionType): String = {
    t match {
      case TBool => "writeBool"
      case TByte => "writeByte"
      case TI16 => "writeI16"
      case TI32 => "writeI32"
      case TI64 => "writeI64"
      case TDouble => "writeDouble"
      case TString => "writeString"
      case TBinary => "writeBinary"
      case x => "????" + x + "????"
    }
  }

  def scalaType(t: FunctionType): String = {
    t match {
      case Void => "Void"
      case TBool => "Boolean"
      case TByte => "Byte"
      case TI16 => "Short"
      case TI32 => "Int"
      case TI64 => "Long"
      case TDouble => "Double"
      case TString => "String"
      case TBinary => "Array[Byte]"
      case ReferenceType(x) => x
      case MapType(k, v, _) => "Map[" + scalaType(k) + ", " + scalaType(v) + "]"
      case SetType(x, _) => "Set[" + scalaType(x) + "]"
      case ListType(x, _) => "Seq[" + scalaType(x) + "]"
    }
  }

  def javaType(t: FunctionType): String = {
    t match {
      case Void => "Void"
      case TBool => "java.lang.Boolean"
      case TByte => "java.lang.Byte"
      case TI16 => "java.lang.Short"
      case TI32 => "java.lang.Integer"
      case TI64 => "java.lang.Long"
      case TDouble => "java.lang.Double"
      case TString => "String"
      case TBinary => "ByteBuffer"
      case ReferenceType(x) => x
      case MapType(k, v, _) => "java.util.Map[" + javaType(k) + ", " + javaType(v) + "]"
      case SetType(x, _) => "java.util.Set[" + javaType(x) + "]"
      case ListType(x, _) => "java.util.List[" + javaType(x) + "]"
    }
  }

  def javaize(name: String, t: FunctionType): String = {
    t match {
      case TBool => name + ".booleanValue"
      case TByte => name + ".byteValue"
      case TI16 => name + ".shortValue"
      case TI32 => name + ".intValue"
      case TI64 => name + ".longValue"
      case TDouble => name + ".doubleValue"
      case TString => name
      case TBinary => name
      case ReferenceType(x) => x + ".toThrift"
      case MapType(k, v, _) => "asScalaMap(" + name + ").view.map { case (k, v) => (" + javaize("k", k) + ", " + javaize("v", v) + ") }"
      case SetType(x, _) => "asScalaSet(" + name + ").view.map { x => " + javaize("x", x) + " }"
      case ListType(x, _) => "asScalaBuffer(" + name + ").view.map { x => " + javaize("x", x) + " }"
    }
  }

  def scalaize(name: String, t: FunctionType): String = {
    "FIXME"
  }

  implicit def string2indent(underlying: String) = new Object {
    def indent(level: Int = 1): String = underlying.split("\\n").map { ("  " * level) + _ }.mkString("\n")
    def indent: String = indent(1)
  }
  implicit def seq2indent(underlying: Seq[String]) = new Object {
    def indent(level: Int = 1): String = underlying.mkString("\n").indent(level)
    def indent: String = indent(1)
  }
  implicit def array2indent(underlying: Array[String]) = new Object {
    def indent(level: Int = 1): String = underlying.mkString("\n").indent(level)
    def indent: String = indent(1)
  }

  def apply(enum: Enum): String = enumTemplate(enum, this)
  def apply(consts: ConstList): String = constsTemplate(consts, this)
  def apply(const: Const): String = constTemplate(const, this)
  def apply(struct: Struct): String = structTemplate(struct, this)

  def apply(doc: Document): String = {
    javaNamespace = doc.headers.collect {
      case Namespace("java", x) => x
    }.headOption.getOrElse("thrift")
    scalaNamespace = doc.headers.collect {
      case Namespace("scala", x) => x
    }.headOption.getOrElse(javaNamespace)

    apply(ConstList(doc.defs.collect { case c @ Const(_, _, _) => c }))
    doc.defs.foreach {
      case enum @ Enum(_, _) =>
        apply(enum)
      case Const(_, _, _) => // Already dealt with you
      case _ => // nothing for now.
    }
    ""
  }
}
