package com.twitter.scrooge

import AST._

object ScalaGenerator {
  val serviceTemplateText =
"""// autogenerated by scrooge.

package {{scalaNamespace}}

import java.nio.ByteBuffer
import scala.collection.{Map, Set}
import com.twitter.conversions.time._
import com.twitter.finagle.builder._
import com.twitter.finagle.stats._
import com.twitter.finagle.thrift._
import com.twitter.logging.Logger
import com.twitter.ostrich.admin.Service
import org.apache.thrift.protocol._

/*
import java.net.InetSocketAddress
import java.util.{List => JList, Map => JMap, Set => JSet}
import scala.collection.mutable

import scala.collection.JavaConversions._
import com.twitter.util._
*/

trait {{service.name}} {{service.parent.map { " extends " + _ }.getOrElse("") }} {
  implicit def voidUnit(f: Future[_]): Future[java.lang.Void] = f.map(x=>null)

{{service.functions.map { f => "  " + serviceFunctionTemplate(f, scope) }.mkString}}

  def toThrift = new {{service.name}}ThriftAdapter(this)
}

object {{service.name}} {
  trait Server extends Service with {{service.name}} {
    val log = Logger.get(getClass)

    def thriftCodec = ThriftServerFramedCodec()
    val thriftProtocolFactory = new TBinaryProtocol.Factory()
    val thriftPort: Int
    val serverName: String

    var server: Server = null

    def start = {
      val thriftImpl = new {{javaNamespace}}.{{service.name}}.Service(toThrift, thriftProtocolFactory)
      val serverAddr = new InetSocketAddress(thriftPort)
      server = ServerBuilder().codec(thriftCodec).name(serverName).reportTo(new OstrichStatsReceiver).bindTo(serverAddr).build(thriftImpl)
    }

    def shutdown = synchronized {
      if (server != null) {
        server.close(0.seconds)
      }
    }
  }
}

"""

  val serviceFunctionTemplateText =
    """def {{name}}({{ args.map { f => serviceArgTemplate(f, scope) }.mkString(", ") }}): Future[{{scalaType(`type`)}}]""" + "\n"

  val serviceArgTemplateText =
    """{{name}}: {{if (optional) "Option[" else ""}}{{scalaType(`type`)}}{{if (optional) "]" else ""}}"""

  case class ScalaService(scalaNamespace: String, javaNamespace: String, service: Service)
}

// maybe should eventually go elsewhere.
class ScalaGenerator {
  import ScalaGenerator._

  val serviceTemplate = Template[ScalaService](serviceTemplateText)
  val serviceFunctionTemplate = Template[Function](serviceFunctionTemplateText)
  val serviceArgTemplate = Template[Field](serviceArgTemplateText)

  def scalaType(t: FunctionType): String = {
    t match {
      case Void => "Void"
      case TBool => "Boolean"
      case TByte => "Byte"
      case TI16 => "Short"
      case TI32 => "Int"
      case TI64 => "Long"
      case TDouble => "Double"
      case TString => "String"
      case TBinary => "ByteBuffer"
      case ReferenceType(x) => x
      case MapType(k, v, _) => "Map[" + scalaType(k) + ", " + scalaType(v) + "]"
      case SetType(x, _) => "Set[" + scalaType(x) + "]"
      case ListType(x, _) => "Seq[" + scalaType(x) + "]"
    }
  }

  def apply(doc: Document): String = {
    val javaNamespace = doc.headers.collect {
      case Namespace("java", x) => x
    }.headOption.getOrElse("thrift")
    val scalaNamespace = doc.headers.collect {
      case Namespace("scala", x) => x
    }.headOption.getOrElse(javaNamespace)

    doc.defs.foreach {
      case service @ Service(_, _, _) =>
        val scalaService = ScalaService(scalaNamespace, javaNamespace, service)
        println(serviceTemplate(scalaService, this))
      case _ => // nothing for now.
    }
    ""
  }
}
